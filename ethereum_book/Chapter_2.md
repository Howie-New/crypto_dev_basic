# 第二章 以太坊基础

[上一章：什么是以太坊](Chapter_1.md)

本章我们将开始探索以太坊。我们会学习如何使用钱包、创建交易，以及运行一个基本的智能合约。

## 以太币货币单位（Ether Currency Units）

以太坊的货币单位称为 *以太币*（ether），也被标识为 ETH，或使用符号 Ξ（源自希腊字母 Xi，形似风格化的大写字母 E），较少见的还有 ♦。例如：1 ether、1 ETH、Ξ1 或 ♦1。

> **提示**
>
> Ξ 使用 Unicode 字符 U+039E，♦ 使用 U+2666。

以太币可以细分为更小的单位，最小单位名为 *wei*。1 ether = 10^18^ wei（即 1,000,000,000,000,000,000 wei）。你可能会听到有人把这个货币称为"以太坊"，但这是初学者常见的错误——以太坊（Ethereum）是系统，以太币（ether）才是货币。

以太币的值在以太坊内部始终以 wei 为单位的无符号整数表示。当你交易 1 ether 时，实际编码的是 1,000,000,000,000,000,000 wei。

以太币的各种面额既有国际单位制（SI）的科学名称，也有向计算机和密码学先驱致敬的俗称。下表展示了各种单位及其名称，为与内部表示保持一致，表中以 wei 为基准（第一行），ether 显示为 10^18^ wei（第七行）：

**表 2-1：以太币面额和单位名称**

| 值（wei） | 指数 | 俗称 | SI 名称 |
|---|---|---|---|
| 1 | 1 | Wei | Wei |
| 1,000 | 10^3^ | Babbage | Kilowei 或 femtoether |
| 1,000,000 | 10^6^ | Lovelace | Megawei 或 picoether |
| 1,000,000,000 | 10^9^ | Shannon | Gigawei 或 nanoether |
| 1,000,000,000,000 | 10^12^ | Szabo | Microether 或 micro |
| 1,000,000,000,000,000 | 10^15^ | Finney | Milliether 或 milli |
| *1,000,000,000,000,000,000* | *10^18^* | *Ether* | *Ether* |
| 1,000,000,000,000,000,000,000 | 10^21^ | Grand | Kiloether |
| 1,000,000,000,000,000,000,000,000 | 10^24^ | | Megaether |

## 选择以太坊钱包

*钱包*（wallet）这个术语有很多含义，但定义都是相关的，日常使用时本质上指的是同一件事。我们用 *钱包* 来指代帮助你管理以太坊账户的软件应用程序。简而言之，以太坊钱包是你通往以太坊系统的门户，它保管你的密钥，可以代表你创建和广播交易。选择以太坊钱包可能比较困难，因为有很多不同功能和设计的选项。有些更适合初学者，有些更适合专家。以太坊平台本身仍在不断改进，"最好"的钱包往往是能够适应平台升级变化的那些。

不过不用担心！如果你选了一个钱包但不喜欢它的使用方式——或者一开始喜欢但后来想尝试其他的——你可以很容易地更换钱包。只需创建一笔交易将资金从旧钱包发送到新钱包，或者导出私钥并导入到新钱包即可。

请记住，钱包应用程序必须能访问你的私钥才能工作，因此只从你信任的来源下载和使用钱包应用程序至关重要。幸运的是，通常来说，钱包应用程序越流行，就越值得信赖。尽管如此，"不要把所有鸡蛋放在一个篮子里"是个好习惯，建议将你的以太坊账户分散在多个钱包和助记词中。

以下是一些不错的入门钱包；选择这些钱包并不代表对其质量或安全性的背书，它们只是用于演示和测试的良好起点。以下钱包都同时提供浏览器扩展和移动端版本：

**MetaMask**

MetaMask 易于使用，便于测试，因为它可以连接到各种以太坊节点和测试区块链。

**Rabby Wallet**

Rabby 通常是新用户的好选择，因为它设计简洁、易于使用，并内置了许多安全功能。

**Phantom**

Phantom 是一款支持以太坊及其他非 EVM 链的钱包。

**OKX Wallet**

OKX Wallet 是一款自托管的多链钱包，支持 50 多条区块链，内置跨链 DEX、DeFi 和 NFT 市场等 Web3 功能。其代码开源并经过独立安全审计，适合需要多链交互的用户。

## 控制与责任

像以太坊这样的开放区块链之所以重要，是因为它们作为*去中心化*系统运行。这意味着很多事情，但其中一个关键方面是，以太坊的每个用户都可以——也应该——控制自己的*私钥*，私钥控制着对资金和智能合约的访问。我们有时把对资金和智能合约的访问权组合称为*账户*或*钱包*。这些术语的功能可能相当复杂，我们稍后会详细讨论。但作为基本原则，可以简单理解为：一个私钥等于一个"账户"。一些用户选择放弃对私钥的控制，使用第三方托管人，如在线中心化交易所。在本书中，我们将教你如何掌控和管理自己的私钥。

控制权带来巨大的责任。如果你丢失了私钥，你将失去对资金和合约的访问权。没有人能帮你恢复访问权——你的资金将永远锁定。以下是一些帮助你管理这一责任的建议：

- 不要在安全方面临时凑合。使用经过验证的标准方法。

- 账户越重要（例如，控制的资金价值相对于你的总资产越高），应采取的安全措施级别就越高。

- 硬件钱包设备可以提供最高级别的安全性之一，但并非每个账户都需要这个级别。

- 永远不要以明文形式存储私钥，尤其是数字形式。幸运的是，如今大多数用户界面不会让你看到原始私钥，除非先弹出多个警告。

- 当系统提示你以助记词形式备份密钥时，用纸和笔做物理备份。不要把这个任务留到"以后"——你会忘记的。这些备份可以在你丢失系统中所有数据、忘记或丢失密码时用于重建私钥。但攻击者也可以用它们获取你的私钥，所以永远不要以数字形式存储，并至少安全存放一份物理副本。

- 在转移任何大额资金（尤其是到新地址）之前，先做一笔小额测试交易（例如价值不到 1 美元），等待确认收到。

- 创建新账户时，先只向新地址发送一笔小额测试交易。收到测试交易后，尝试从该账户再发送回来。账户创建可能出错的原因有很多，如果出了问题，用小额损失发现总比大额损失好。如果测试成功，一切正常（也可以使用测试网来避免任何损失）。

- 公共区块浏览器是独立查看交易是否被网络接受的简便方式；虽然这些信息本就在区块链上公开，但区块浏览器让访问变得极其方便。不过，这种便利对隐私有负面影响，因为你向区块浏览器暴露了你的地址，它们可以追踪你。

- 公共区块浏览器通常可靠，但并非总是如此——不要盲目信任它们。

- 不要向本书中展示的任何地址发送资金。私钥列在书中，有人会立即取走那些钱。

现在我们已经介绍了密钥管理和安全的一些基本最佳实践，让我们开始使用 MetaMask 吧！

## MetaMask 入门

打开 Google Chrome 浏览器，导航到 [扩展程序](https://chrome.google.com/webstore/category/extensions)。搜索"MetaMask"，点击狐狸图标。你应该会看到类似图 2-1 的页面。

![MetaMask Chrome 扩展详情页](images/ch2/maet_0201.png)

图 2-1：MetaMask Chrome 扩展详情页

验证你下载的是真正的 MetaMask 扩展非常重要，因为有时恶意扩展能够绕过 Google 的过滤器。真正的 MetaMask 具有以下特征：

- 地址栏中显示 ID `nkbihfbeogaeaoehlefnkodbefgpgknn`

- 由 [*https://metamask.io*](https://metamask.io) 提供

- 有超过 5,400 条评论

- 有超过 1500 万用户

确认你正在查看正确的扩展后，点击"添加到 Chrome"进行安装。

### 创建钱包

安装 MetaMask 后，你应该会在浏览器工具栏中看到一个新图标（狐狸头）。点击它开始使用。系统会要求你接受条款和条件，然后输入密码创建新的以太坊钱包（见图 2-2）。

![MetaMask Chrome 扩展密码页面](images/ch2/maet_0202.png)

图 2-2：MetaMask Chrome 扩展密码页面

> **提示**
>
> 密码控制对 MetaMask 的访问，使任何能访问你浏览器的人都无法使用它。这个密码仅用于本地设备；如果攻击者获得了私钥或助记词，他们将能够访问你地址中的资金。如果攻击者有私钥或助记词，则不需要密码。

设置密码后，MetaMask 会为你生成一个钱包，并显示一个由 12 个英文单词组成的*助记词备份*（见图 2-3）。如果 MetaMask 或你的电脑出现问题，这些词可以在任何兼容的钱包中用于恢复对资金的访问。恢复时不需要密码；这 12 个词就足够了。

![MetaMask 创建的钱包助记词备份](images/ch2/maet_0203.png)

图 2-3：MetaMask 创建的钱包助记词备份

> **提示**
>
> 用纸张备份助记词（12 个词），备份两份。将两份纸质备份存放在两个独立的安全位置，如防火保险箱、上锁的抽屉或银行保险柜。将纸质备份视为与你存储在以太坊钱包中等值的现金。任何能接触到这些词的人都可以获取并窃取你的资金。我们将在第 5 章详细讨论如何安全保管助记词。

确认你已安全存储助记词后，你就能看到以太坊账户的详细信息，如图 2-4 所示。

![MetaMask 中的以太坊账户](images/ch2/maet_0204.png)

图 2-4：MetaMask 中的以太坊账户

> **注意**
>
> 不要向本书中显示的地址发送任何资产。助记词是公开用于教育目的的，发送到这些地址的任何资产都可能丢失。

你的账户页面显示账户名称（默认为"Account 1"）、以太坊地址（示例中为 `0xaa529…f17f`），以及一个彩色图标帮助你直观区分此账户与其他账户。在账户页面顶部，你可以看到当前连接的以太坊网络（示例中为"Main Network"）。

恭喜！你已经设置好了第一个以太坊钱包。

### 切换网络

如你在 MetaMask 账户页面所见，你可以选择多个以太坊网络。默认情况下，MetaMask 会尝试连接到主网。其他选择包括公共测试网、你选择的任何以太坊节点，或在你自己电脑上运行私有区块链的节点（localhost）：

**以太坊主网（Main Ethereum Network）**

主要的公共以太坊区块链。真正的 ETH、真正的价值、真正的后果。

**Sepolia 测试网（Sepolia Test Network）**

> **译注**（2026 年 2 月更新）：Ropsten、Kovan、Rinkeby 测试网已于 2022-2023 年停止支持。目前以太坊主要支持的测试网为 Sepolia（通用开发测试）和 Holesky（质押和基础设施测试）。

Sepolia 于 2021 年 10 月由以太坊核心开发者启动，最初为权威证明（PoA）网络，后已过渡到 PoS 共识，与以太坊主网环境保持一致。

**Holesky 测试网（Holesky Test Network）**

Holesky 测试网是以太坊用于质押、基础设施和协议开发的高级测试环境。

**Localhost 8545**

连接到与浏览器在同一台电脑上运行的节点。该节点可以是任何公共区块链（主网或测试网）或私有测试网的一部分。

**自定义 RPC（Custom RPC）**

允许你将 MetaMask 连接到任何具有 Geth 兼容远程过程调用（RPC）接口的节点。该节点可以是任何公共或私有区块链的一部分。

> **注意**
>
> 你的 MetaMask 钱包在所有连接的网络上使用相同的私钥和以太坊地址。但是，你的以太坊地址在每个网络上的余额是不同的。例如，如果你用密钥在 Sepolia 测试网上发送以太币，其他网络上的余额不会受到影响。

### 获取测试以太币

你的第一个任务是为钱包充值。你不会在主网上做这件事，因为真正的以太币需要花钱，处理它需要更多经验。现在，你将用一些测试网以太币加载钱包。

通过点击左上角的以太坊图标，将 MetaMask 切换到 Sepolia 测试网；打开"显示测试网络"选项，然后点击 Sepolia，如图 2-5 所示。

![MetaMask 网络选择](images/ch2/maet_0205.png)

图 2-5：MetaMask 网络选择

点击"Buy"（购买），然后导航到[水龙头列表](https://ethereum.org/developers/docs/networks/#sepolia)中的一个水龙头。选择你要使用的水龙头——它们基本上都是等效的——你可以在测试网上请求以太币，如图 2-6 所示。

![MetaMask Sepolia 测试水龙头](images/ch2/maet_0206.png)

图 2-6：MetaMask Sepolia 测试水龙头

请求测试网以太币的交易 ID 看起来像这样：

    0x471273d9417e98e7f1adaae61e53a353b2d2313de2e71fc4b6184bf5a63fa0ae

几秒钟后，新交易将被 Sepolia 网络处理，你的 MetaMask 钱包将显示 0.05 ETH 的余额（这取决于水龙头愿意发送多少以太币）。现在，点击浏览器扩展中的第一笔交易，然后点击"View on block explorer"（在区块浏览器中查看），如图 2-7 所示。这将导航到*区块浏览器*，一个允许你可视化和探索区块、地址和交易的网站。

![从 MetaMask 查看交易](images/ch2/maet_0207.png)

图 2-7：从 MetaMask 查看交易

MetaMask 使用 [Etherscan 区块浏览器](https://etherscan.io)，这是较受欢迎的以太坊区块浏览器之一。包含 Sepolia 测试水龙头付款的交易如图 2-8 所示。

![Etherscan Sepolia 区块浏览器](images/ch2/maet_0208.png)

图 2-8：Etherscan Sepolia 区块浏览器

该交易已记录在 Sepolia 区块链上，任何人都可以随时查看，只需搜索交易 ID。尝试在 [*sepolia.etherscan.io* 网站](http://sepolia.etherscan.io) 输入交易哈希亲自查看：

    0x471273d9417e98e7f1adaae61e53a353b2d2313de2e71fc4b6184bf5a63fa0ae

### 使用 MetaMask 发送以太币

从 Sepolia 测试水龙头收到第一笔测试以太币后，你可以尝试发送一些以太币进行实验，例如将一些发送回水龙头或发送到任何其他地址。在这个例子中，我们将尝试向 Vitalik Buterin 发送一些测试网以太币，如图 2-9 所示。

![向某个地址发送 0.05 ether](images/ch2/maet_0209.png)

图 2-9：向某个地址发送 0.05 ether

糟糕！你可能注意到无法完成交易——MetaMask 提示余额不足。乍一看这可能令人困惑：你有 0.05 ETH，你想发送 0.05 ETH，为什么 MetaMask 说你资金不足？

答案是 gas 的成本。每笔以太坊交易都需要支付费用，由网络收取以验证交易。以太坊的费用以一种名为 *gas* 的虚拟货币计价。你用以太币支付 gas 费用，作为交易的一部分。

> **注意**
>
> 测试网也需要费用。如果没有费用，测试网的行为将与主网不同，使其成为不充分的测试平台。费用还保护测试网免受拒绝服务攻击和设计不良的合约（例如无限循环）的影响，就像保护主网一样。

> **译注**（2026 年 2 月更新）：自 EIP-1559（2021 年 8 月 London 升级）起，以太坊的 gas 费用模型已更新为 Base Fee（基础费用）+ Priority Fee（优先费用/小费）机制，取代了原来的简单拍卖模式。Base Fee 根据网络拥堵程度自动调整并被销毁，用户只需设置最高愿意支付的费用和优先费用。

当你发送交易时，MetaMask 会计算最近成功交易的平均 gas 价格——例如 3 gwei（即 3 gigawei）。Wei 是以太币货币的最小细分单位，如我们在"以太币货币单位"中讨论的那样。gas 限制设置为发送基本交易的成本：21,000 gas 单位，这是发送交易可使用的最小 gas 量。因此，你将花费的最大 ETH 数量为 3 × 21,000 gwei = 63,000 gwei = 0.000063 ETH。（请注意，平均 gas 价格可能会波动。我们将在后面的章节中看到如何增加或减少 gas 限制，以确保你的交易在需要时获得优先处理。）

总之，进行 0.05 ETH 的交易实际需要 0.050063 ETH。点击"Reject"（拒绝）取消此交易。让我们再试一次，这次发送 0.01 ETH。

### 探索地址的交易历史

现在，你已经成为使用 MetaMask 发送和接收测试以太币的专家。你的钱包已经收到和发送了付款。你可以使用 [*sepolia.etherscan.io* 区块浏览器](http://sepolia.etherscan.io) 查看所有这些交易。你可以复制钱包地址并粘贴到区块浏览器的搜索框中，或者让 MetaMask 为你打开页面。在 MetaMask 的账户图标旁边，你会看到一个显示三个点的按钮。点击它显示账户相关选项菜单（见图 2-10）。

![MetaMask 账户上下文菜单](images/ch2/maet_0210.png)

图 2-10：MetaMask 账户上下文菜单

> **提示**
>
> MetaMask 的默认设置不太注重隐私。建议仔细分析"设置 → 安全与隐私"中的设置。熟悉 MetaMask 的工作原理后，还建议将以太坊主网网络从默认网络更改为使用符合你需求的隐私设置的 RPC。最私密的解决方案是拥有自己的节点和可连接的 RPC；我们将在第 3 章中看到如何做到这一点。

选择"View account on Etherscan"（在 Etherscan 上查看账户），在区块浏览器中打开显示账户交易历史的网页，如图 2-11 所示。

![Etherscan 上的地址交易历史](images/ch2/maet_0211.png)

图 2-11：Etherscan 上的地址交易历史

在这里你可以看到以太坊地址的完整交易历史。它显示了 Sepolia 区块链上记录的所有你的地址作为发送方或接收方的交易。点击其中一些交易查看更多详情。

> **警告**
>
> 注意，有一种已知的攻击叫做*地址投毒*（address poisoning），可以在区块浏览器上显示带有伪造地址的交易。区块浏览器应该用于快速检查，但显示的信息可能不准确。

你可以探索任何地址的交易历史。查看 Sepolia 测试水龙头地址的交易历史（提示：它是你地址中最早付款所列的"发送方"地址）。你可以看到从水龙头发送给你和其他地址的所有测试以太币。你看到的每笔交易都可能带你到更多地址和更多交易。不久，你就会迷失在相互关联的数据迷宫中。公共区块链包含大量信息，所有这些都可以通过编程方式探索，我们将在未来的示例中看到。

## 世界计算机简介

你现在已经创建了一个钱包，发送和接收了以太币。到目前为止，我们把以太坊当作一种加密货币。但以太坊远不止于此。事实上，加密货币功能是为以太坊作为去中心化世界计算机的功能服务的。以太币旨在用于支付运行*智能合约*（smart contracts），即在称为*以太坊虚拟机*（EVM）的模拟计算机上运行的计算机程序。

EVM 是一个全局单例（global singleton），意味着它的运行就像是一台全局单实例计算机，无处不在地运行。以太坊网络上的每个节点运行 EVM 的本地副本以验证合约执行，而以太坊区块链记录这台世界计算机在处理交易和智能合约时不断变化的*状态*。我们将在第 14 章更详细地讨论这一点。

## 外部所有账户和合约（EOA and Contracts）

你在 MetaMask 钱包中创建的账户类型称为*外部所有账户*（Externally Owned Account，EOA）。EOA 是拥有私钥的账户；拥有私钥意味着对资金或合约的访问控制。

你可能猜到还有另一种类型的账户。那就是*合约账户*（contract account）。合约账户拥有智能合约代码，而简单的 EOA 不能有。此外，合约账户没有私钥。相反，它由其智能合约代码的逻辑所拥有（和控制）：即在合约账户创建时记录在以太坊区块链上并由 EVM 执行的软件程序。

合约有地址，就像 EOA 一样。合约也可以发送和接收以太币，就像 EOA 一样。然而，当交易目标是合约地址时，它会导致该合约在 EVM 中*运行*，使用交易——以及交易的数据——作为其输入。除了以太币之外，交易还可以包含*数据*，指示要运行合约中的哪个特定函数以及传递给该函数的参数。通过这种方式，交易可以*调用*合约中的函数。

请注意，因为合约账户没有私钥，它无法*发起*交易。只有 EOA 可以发起交易，但合约可以通过调用其他合约来*响应*交易，构建复杂的执行路径。

在接下来的几节中，我们将编写第一个合约。然后你将学习如何使用 MetaMask 钱包和测试以太币在 Sepolia 测试网上创建、资助和使用该合约。

## 一个简单的合约：测试以太币水龙头

以太坊有几种不同的高级语言，都可以用来编写合约并生成 EVM 字节码。你可以在第 7 章阅读最重要和有趣的几种。一种高级语言是智能合约编程的主流选择：Solidity。Solidity 由 Gavin Wood 创建，已成为以太坊（及其他链）中使用最广泛的语言。我们将使用 Solidity 编写第一个合约。

作为第一个示例（示例 2-1），我们将编写一个控制水龙头的合约。你已经使用过水龙头在 Sepolia 测试网上获取测试以太币。*水龙头*是一件相对简单的事情：它向任何请求的地址发放以太币，并且可以被补充。

##### 示例 2-1：*Faucet.sol*：实现水龙头的 Solidity 合约

```solidity
pragma solidity 0.8.26;
// SPDX-License-Identifier: GPL-3.0

// 我们的第一个合约是一个水龙头！
contract Faucet {

    // 向任何请求者发放以太币
    function withdraw(uint256 _withdrawAmount, address payable _to) public {

        // 限制提款金额
        require(_withdrawAmount <= 1000000000000);

        // 将金额发送到请求的地址
        _to.transfer(_withdrawAmount);
    }

    // 接收以太币的函数。msg.data 必须为空
    receive() external payable {}

    // 当 msg.data 不为空时调用的回退函数
    fallback() external payable {}
}
```

这是一个非常简单的合约，尽可能简单。它也是一个*有缺陷*的合约，展示了一些不良做法和安全漏洞。我们将在后面的章节中通过检查它的许多缺陷来学习。但现在，让我们逐行看看这个合约做了什么以及它是如何工作的。你会很快注意到 Solidity 的许多元素与现有的编程语言相似，如 JavaScript、Java 或 C++。

第一行是 `pragma` 语句：

    pragma solidity 0.8.26;

通过在 Solidity 源文件顶部包含这一行，你可以确保代码使用 Solidity 编译器 0.8.26 版本编译，确保兼容性并避免使用不同编译器版本可能出现的潜在问题。

接下来是一个注释，表明智能合约在 GPL-3.0 许可证下授权：

    // SPDX-License-Identifier: GPL-3.0

这对于法律和合规原因很重要，因为它告知用户和开发者关于代码使用和分发的权利和义务。

注释是给人类阅读的，不包含在可执行的 EVM 字节码中。我们通常把注释放在要解释的代码之前，有时放在同一行。注释以两个正斜杠开始：`//`。从第一个斜杠到该行结束的所有内容都被视为空白行并被忽略。

这也是一个注释：

    // 我们的第一个合约是一个水龙头！

下一行是我们实际合约开始的地方：

    contract Faucet {

这一行声明了一个 `contract` 对象，类似于其他面向对象语言中的 `class` 声明。合约定义包括花括号（`{}`）之间的所有行，它们定义了一个*作用域*，就像花括号在许多其他编程语言中的使用方式一样。

接下来，我们声明 `Faucet` 合约的第一个函数：

    function withdraw(uint256 _withdrawAmount, address payable _to) public {

函数名为 `withdraw`，它接受一个名为 `_withdrawAmount` 的无符号整数（`uint256`）和一个名为 `_to` 的 `address payable`。它被声明为 public 函数，意味着它可以被其他合约调用。函数定义在花括号之间。`withdraw` 函数的第一部分设置了提款限制：

    require(_withdrawAmount <= 1000000000000);

它使用内置的 Solidity 函数 `require` 来测试一个前提条件：`_withdrawAmount` 小于或等于 1,000,000,000,000 wei，这是以太币的基本单位（见表 2-1），相当于 0.000001 ether。如果用大于该金额的 `withdraw_amount` 调用 `withdraw` 函数，这里的 `require` 函数将导致合约执行停止并以*异常*失败。注意在 Solidity 中，语句需要以分号结束。

合约的这部分是我们水龙头的主要逻辑。它通过设置提款限制来控制合约的资金流出。这是一个非常简单的控制，但可以让你一窥可编程区块链的强大之处：去中心化的软件控制着资金。

这里是合约的第一个设计缺陷。虽然不是安全缺陷，但最好总是在 `require` 语句中添加错误消息。这样，当用户的交易因 `require` 语句失败时，原因就很清楚了。

修正后的 `require` 语句是：

    require(_withdrawAmount <= 1000000000000, "请求的金额过多，请尝试较小的金额！");

接下来是实际的提款：

    _to.transfer(_withdrawAmount);

这里发生了一些有趣的事情。`transfer` 函数是一个内置函数，将以太币从当前合约转移到另一个指定地址——在这种情况下是 `_to` 地址。`transfer` 函数接受一个金额作为其唯一参数。我们传递了之前声明为 `withdraw` 函数参数的 `_withdrawAmount` 值。

这是可能的，因为 `_to` 地址被定义为 payable。内置函数 `transfer` 和 `send` 只能在 payable 地址上调用。这是代码中的第二个缺陷：虽然如果 EOA 调用 `withdraw` 函数，`transfer` 完全没问题，但如果另一个合约触发此函数，它就会变得有问题。在这种情况下，交易可能会失败，因为 `transfer` 函数只能使用最多 2,300 gas，而多个合约调用很可能超过此限制。要解决这个问题，你可以使用内置的 `call` 函数代替 `transfer` 和 `send`。但是，这个内置函数需要正确处理以避免安全缺陷。目前，我们将保留内置的 `transfer` 函数不变。

下一行是结束花括号，表示我们 `withdraw` 函数定义的结束。

接下来，我们声明两个更多的函数：

    receive() external payable {}
    fallback() external payable {}

这些函数是 `fallback` 和 `receive` 函数，如果触发合约的交易没有指定合约中声明的任何函数，或根本没有函数，或不包含数据，它们就会被调用。合约可以有这些函数，通常是接收以太币的函数。当 *msg.data* 为空时，将触发 `receive` 函数；当 *msg.data* 不为空时，将触发 `fallback` 函数。

在我们的 `fallback` 函数下面是最终的结束花括号，它关闭了合约 `Faucet` 的定义。就是这样！

## 编译水龙头合约

现在我们有了第一个示例合约，需要使用 Solidity 编译器将 Solidity 代码转换为 EVM 字节码，以便它可以在区块链上由 EVM 执行。

Solidity 编译器有独立的可执行文件，也作为各种框架的一部分，并捆绑在 IDE 中。为了保持简单，我们将使用一个流行的 IDE：Remix。

使用你的 Chrome 浏览器（带有之前安装的 MetaMask 钱包）导航到 [Remix IDE](https://remix.ethereum.org)。

首次加载 Remix 时，它会以一个名为 *Storage.sol* 的示例合约开始。我们不需要它，所以通过点击标签页角落的 `x` 关闭它，如图 2-12 所示。

![关闭默认示例标签页](images/ch2/maet_0212.png)

图 2-12：关闭默认示例标签页

现在，创建一个新文件，如图 2-13 所示。将新文件命名为 *Faucet.sol*。

![创建新合约](images/ch2/maet_0213.png)

图 2-13：创建新合约

打开新标签页后，复制并粘贴示例 *Faucet.sol* 中的代码，如图 2-14 所示。

![将 Faucet 示例代码复制到新合约](images/ch2/maet_0214.png)

图 2-14：将 Faucet 示例代码复制到新合约

将 *Faucet.sol* 合约加载到 Remix IDE 后，导航到 Remix 的编译部分，点击"Compile Faucet.sol"。如果一切顺利，你会看到一个绿色方框（见图 2-15）。

![Remix 成功编译 Faucet.sol 合约](images/ch2/maet_0215.png)

图 2-15：Remix 成功编译 *Faucet.sol* 合约

如果出现问题，最可能的原因是 Remix IDE 使用的 Solidity 编译器版本与 0.8.26 不同。在这种情况下，我们的 `pragma` 指令将阻止 *Faucet.sol* 编译。要更改编译器版本，请转到 Compiler 标签页，将版本设置为 0.8.26，然后重试。

Solidity 编译器现在已将我们的 *Faucet.sol* 编译为 EVM 字节码。如果你好奇，字节码看起来像这样：

    6080604052348015600e575f80fd5b506101af8061001c5f395ff3fe608060405260043610610020575f3560
    e01c8062f714ce1461002957610027565b3661002757005b005b348015610034575f80fd5b5061004f600480
    360381019061004a919061013b565b610051565b005b64e8d4a51000821115610062575f80fd5b8073ffffff
    ffffffffffffffffffffffffffffffffff166108fc8390811502906040515f60405180830381858888f19350
    5050501580156100a5573d5f803e3d5ffd5b505050565b5f80fd5b5f819050919050565b6100c0816100ae56
    5b81146100ca575f80fd5b50565b5f813590506100db816100b7565b92915050565b5f73ffffffffffffffff
    ffffffffffffffffffffffff82169050919050565b5f61010a826100e1565b9050919050565b61011a816101
    00565b8114610124575f80fd5b50565b5f8135905061013581610111565b92915050565b5f80604083850312
    15610151576101506100aa565b5b5f61015e858286016100cd565b925050602061016f85828601610127565b
    915050925092905056fea26469706673582212207de2f4d88c747c9332dceef5dcd739f3380ec8a8c2167a29
    2ba64ee24fa32a8a64736f6c634300081a0033

你是不是很高兴使用像 Solidity 这样的高级语言，而不是直接在 EVM 字节码中编程？我们也是！

## 在区块链上创建合约

我们有了合约，并将其编译成字节码。现在，我们需要在以太坊区块链上"注册"该合约。我们将使用 Sepolia 测试网来测试我们的合约，所以这就是我们要提交的区块链。

在区块链上注册合约涉及创建一个特殊交易，其 `to` 字段留空（null）。这个空目的地向以太坊区块链发出信号，表明你想部署一个新合约，而不是向现有地址发送交易。交易的 `data` 字段包含编译后的合约字节码。幸运的是，Remix IDE 会为你处理所有这些，并将交易发送到 MetaMask。

首先，切换到 Run 标签页，在 Environment 下拉选择框中选择"Injected Web3"。这将 Remix IDE 连接到 MetaMask 钱包，并通过 MetaMask 连接到 Sepolia 测试网。完成后，你可以在 Environment 下看到 Sepolia。此外，Account 选择框显示你钱包的地址（见图 2-16）。

![Remix IDE Run 标签页，选择了 Injected Web3 环境](images/ch2/maet_0216.png)

图 2-16：Remix IDE Run 标签页，选择了 Injected Web3 环境

在你刚确认的 Run 设置下方是 `Faucet` 合约，准备创建。点击图 2-16 中显示的 Deploy 按钮。

Remix 将构建特殊的"创建"交易，MetaMask 会要求你批准它，如图 2-17 所示。你会注意到合约创建交易中没有以太币，但有一些字节的数据（编译后的合约）并会消耗一些 gwei 的 gas。点击 Submit 批准它。

![MetaMask 显示合约创建交易](images/ch2/maet_0217.png)

图 2-17：MetaMask 显示合约创建交易

> **译注**（2026 年 2 月更新）：由于以太坊已于 2022 年 9 月完成 The Merge 升级，从 PoW 转为 PoS 共识机制，区块不再由矿工"挖掘"，而是由验证者（validators）验证和确认。因此"等待矿工处理"的说法已过时。

现在你需要等待。合约在 Sepolia 上处理大约需要 15-30 秒。Remix 看起来不会有太多动静，请耐心等待。

合约创建后，它会出现在 Run 标签页的底部（见图 2-18）。

![Faucet 合约已创建！](images/ch2/maet_0218.png)

图 2-18：Faucet 合约已创建！

注意 `Faucet` 合约现在有了自己的地址：Remix 将其显示为"Faucet at 0x4E7…6EA46"（尽管你的地址——随机的字母和数字——会不同）。

## 与合约交互

让我们回顾一下到目前为止学到的内容。以太坊合约是控制资金的程序，在称为 EVM 的虚拟机中运行。它们通过提交字节码的特殊交易创建，记录在区块链上。一旦在区块链上创建，它们就有了以太坊地址，就像钱包一样。任何时候有人向合约地址发送交易，都会导致合约在 EVM 中运行，以交易作为输入。发送到合约地址的交易可能包含以太币或数据或两者都有。如果它们包含以太币，它会被"存入"合约余额。如果它们包含数据，数据可以指定合约中的命名函数并调用它，传递参数给该函数。

### 在区块浏览器中查看合约地址

我们现在在区块链上记录了一个合约，我们可以看到它有一个以太坊地址。让我们在 [*sepolia.etherscan.io* 区块浏览器](http://sepolia.etherscan.io) 中查看它，看看合约是什么样子的。在 Remix IDE 中，点击合约名称旁边的图标复制合约地址（见图 2-19）。

![从 Remix 复制合约地址](images/ch2/maet_0219.png)

图 2-19：从 Remix 复制合约地址

保持 Remix 打开；我们稍后会回来。现在，将浏览器导航到 [*sepolia.etherscan.io*](http://sepolia.etherscan.io)，将地址粘贴到搜索框中。你应该会看到合约的以太坊地址历史，如图 2-20 所示。

![在 Etherscan 区块浏览器中查看 Faucet 合约地址](images/ch2/maet_0220.png)

图 2-20：在 Etherscan 区块浏览器中查看 Faucet 合约地址

### 为合约提供资金

目前，合约的历史中只有一笔交易：合约创建交易。如你所见，合约也没有以太币（余额为零）。这是因为我们在创建交易中没有向合约发送任何以太币，尽管我们本可以这样做。

我们的水龙头需要资金！我们的第一个项目将是使用 MetaMask 向合约发送以太币。你应该仍然在剪贴板中有合约的地址（如果没有，从 Remix 再次复制）。打开 MetaMask，向它发送 0.01 ether，就像发送到任何其他以太坊地址一样（见图 2-21）。

![向合约地址发送 0.01 ether](images/ch2/maet_0221.png)

图 2-21：向合约地址发送 0.01 ether

一分钟后，如果你重新加载 Etherscan 区块浏览器，它会显示合约地址的另一笔交易和更新的 0.01 ether 余额。

还记得我们 *Faucet.sol* 代码中的 `receive` 函数吗？它看起来像这样：

    receive() external payable {}

当你向合约地址发送交易，没有指定要调用哪个函数的数据时，它会调用这个 `receive` 函数。你的交易导致合约在 EVM 中运行，更新其余额。你已经为水龙头提供了资金！

### 从合约中提款

接下来，让我们从水龙头中提取一些资金。要提款，我们必须构造一个调用 `withdraw` 函数并传递 `_withdrawAmount` 和 `_to` 参数给它的交易。为了保持简单，Remix 将为我们构建该交易，MetaMask 将提交它供我们批准。

返回 Remix 标签页，在 Run 标签页下查看合约。你应该看到一个标记为"withdraw"的红色框，其中有一个标记为"uint256 \_withdrawAmount, address \_to"的字段输入（见图 2-22）。

![Remix 中 Faucet.sol 的 withdraw 函数](images/ch2/maet_0222.png)

图 2-22：Remix 中 *Faucet.sol* 的 withdraw 函数

这是 Remix 对合约的接口。它允许我们构建调用合约中定义的函数的交易。我们将输入 `_withdrawAmount` 和 `_to` 地址，然后点击 withdraw 按钮生成交易。

首先，让我们确定 `_withdrawAmount`。我们想尝试提取 0.000001 ether，这是我们合约允许的最大金额。记住，以太坊中的所有货币值在内部都以 wei 计价，我们的 `withdraw` 函数期望 `_withdrawAmount` 也以 wei 计价。我们想要的金额是 0.000001 ether，即 1,000,000,000,000 wei（1 后面跟 12 个零）。

对于 `_to` 地址，我们将使用 MetaMask 中的 Account 1。

> **提示**
>
> 由于 JavaScript 的限制，像 10^17^ 这样大的数字无法被 Remix 处理。相反，我们将它用引号括起来，让 Remix 以字符串形式接收并作为 `BigNumber` 处理。如果我们不用引号括起来，Remix IDE 将无法处理它并显示"Error encoding arguments: Error: Assertion failed"。

在 `_withdrawAmount` 框中输入 `"1000000000000"`（带引号），从 MetaMask 复制粘贴你的 Account 1 地址，然后点击 transact 按钮。（你可能会看到它显示为 withdraw 按钮。图 2-23 显示了函数的展开视图；如果你的视图没有展开，按钮会显示为"withdraw"。）

![在 Remix 中点击 transact 创建提款交易](images/ch2/maet_0223.png)

图 2-23：在 Remix 中点击 transact 创建提款交易

MetaMask 将弹出一个交易窗口供你批准。点击 Submit 将你的提款调用发送到合约（见图 2-24）。

![MetaMask 调用 withdraw 函数的交易](images/ch2/maet_0224.png)

图 2-24：MetaMask 调用 withdraw 函数的交易

等待一分钟，然后重新加载 Etherscan 区块浏览器，查看 `Faucet` 合约地址历史中反映的交易（见图 2-25）。

![Etherscan 显示调用 withdraw 函数的交易](images/ch2/maet_0225.png)

图 2-25：Etherscan 显示调用 withdraw 函数的交易

我们现在看到一笔新交易，目标是合约地址，值为 0 ether。合约余额已更改，现在是 0.009999 ether，因为它按要求发送给我们 0.000001 ether。

但我们在合约地址历史中没有看到"OUT"交易。提款在哪里？合约地址历史页面出现了一个名为 Internal Transactions（内部交易）的新标签页。因为 0.000001 ether 转账源自合约代码，它是一个内部交易（也称为*消息*）。点击该标签页查看它（见图 2-26）。

这个"内部交易"是由合约在这行代码中发送的（*Faucet.sol* 的 `withdraw` 函数）：

    _to.transfer(_withdrawAmount);

![Etherscan 显示从合约转出以太币的内部交易](images/ch2/maet_0226.png)

图 2-26：Etherscan 显示从合约转出以太币的内部交易

回顾一下：你从 MetaMask 钱包发送了一笔包含数据指令的交易，以 0.000001 ether 的 `_withdrawAmount` 参数和一个地址调用 `withdraw` 函数。该交易导致合约在 EVM 中运行。当 EVM 运行 `Faucet` 合约的 `withdraw` 函数时，它首先调用 `require` 函数，验证请求的金额小于或等于最大允许提款 0.000001 ether。然后，它调用 `transfer` 函数向你发送以太币。运行 `transfer` 函数生成了一个内部交易，从合约余额中将 0.000001 ether 存入你的钱包地址。这就是 Etherscan 中 Internal Transactions 标签页显示的内容。

## 总结

在本章中，你使用 MetaMask 设置了一个钱包，并使用 Sepolia 测试网上的水龙头为其充值。你收到了发送到钱包以太坊地址的以太币，然后你向另一个地址发送了以太币。

接下来，你用 Solidity 编写了一个 `Faucet` 合约。你使用 Remix IDE 将合约编译为 EVM 字节码，然后使用 Remix 形成交易并在 Sepolia 区块链上创建了 `Faucet` 合约。创建后，`Faucet` 合约有了一个以太坊地址，你向它发送了一些以太币。最后，你构建了一个交易来调用 `withdraw` 函数，成功请求了 0.000001 ether。合约检查了请求，并通过内部交易发送给你 0.000001 ether。

这可能看起来不多，但你刚刚成功地与控制去中心化世界计算机上资金的软件进行了交互。

我们将在第 7 章做更多 Solidity 智能合约编程，并在第 9 章学习最佳实践和安全考虑。

[下一章：以太坊客户端](Chapter_3.md)
